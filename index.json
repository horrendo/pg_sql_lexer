{"repository_name":"pg_sql_lexer","body":"# pg_sql_lexer\n\nI needed a way to 'minify' SQL statements in another Crystal project. This turned out to be quite tricky so I figured the easiest way was to create a simple lexer and use the tokens to generate a minified representation. This lexer is also written in Crystal (obviously) ðŸ˜€.\n\n[![Build Status](https://travis-ci.org/horrendo/pg_sql_lexer.svg?branch=master)](https://travis-ci.org/horrendo/pg_sql_lexer)\n\n## Installation\n\n- Add the dependency to your `shard.yml`:\n\n```yaml\ndependencies:\n  pg_sql_lexer:\n    github: horrendo/pg_sql_lexer\n```\n\n- Run `shards install`\n\n## Usage\n\n```crystal\nrequire \"pg_sql_lexer\"\n:\nraw_sql = {slurp from a file maybe}\nminified = PgSqlLexer::Formatter.new(PgSqlLexer::Lexer.new(raw_sql).tokens).format_minified\n:\n```\n\nYou can access the documentation [here](https://horrendo.github.io/pg_sql_lexer/)\n\n## Contributing\n\n1. Fork it (<https://github.com/horrendo/pg_sql_lexer/fork>)\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am 'Add some feature'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create a new Pull Request\n\n## Contributors\n\n- [Steve Baldwin](https://github.com/horrendo) - creator and maintainer\n","program":{"html_id":"pg_sql_lexer/toplevel","path":"toplevel.html","kind":"module","full_name":"Top Level Namespace","name":"Top Level Namespace","abstract":false,"superclass":null,"ancestors":[],"locations":[],"repository_name":"pg_sql_lexer","program":true,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"pg_sql_lexer/PgSqlLexer","path":"PgSqlLexer.html","kind":"module","full_name":"PgSqlLexer","name":"PgSqlLexer","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"src/pg_sql_lexer.cr","line_number":6,"url":"https://github.com/horrendo/pg_sql_lexer/blob/1e20f45772969244d736615cdb3823761b75388a/src/pg_sql_lexer.cr#L6"},{"filename":"src/pg_sql_lexer/exceptions.cr","line_number":1,"url":"https://github.com/horrendo/pg_sql_lexer/blob/1e20f45772969244d736615cdb3823761b75388a/src/pg_sql_lexer/exceptions.cr#L1"},{"filename":"src/pg_sql_lexer/formatter.cr","line_number":3,"url":"https://github.com/horrendo/pg_sql_lexer/blob/1e20f45772969244d736615cdb3823761b75388a/src/pg_sql_lexer/formatter.cr#L3"},{"filename":"src/pg_sql_lexer/keyword.cr","line_number":1,"url":"https://github.com/horrendo/pg_sql_lexer/blob/1e20f45772969244d736615cdb3823761b75388a/src/pg_sql_lexer/keyword.cr#L1"},{"filename":"src/pg_sql_lexer/lexer.cr","line_number":5,"url":"https://github.com/horrendo/pg_sql_lexer/blob/1e20f45772969244d736615cdb3823761b75388a/src/pg_sql_lexer/lexer.cr#L5"},{"filename":"src/pg_sql_lexer/token.cr","line_number":1,"url":"https://github.com/horrendo/pg_sql_lexer/blob/1e20f45772969244d736615cdb3823761b75388a/src/pg_sql_lexer/token.cr#L1"}],"repository_name":"pg_sql_lexer","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":"\nAll classes in this shard are in the `PgSqlLexer` module\n","summary":"<p>All classes in this shard are in the <code><a href=\"PgSqlLexer.html\">PgSqlLexer</a></code> module </p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"pg_sql_lexer/PgSqlLexer/Formatter","path":"PgSqlLexer/Formatter.html","kind":"class","full_name":"PgSqlLexer::Formatter","name":"Formatter","abstract":false,"superclass":{"html_id":"pg_sql_lexer/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"pg_sql_lexer/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"pg_sql_lexer/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/pg_sql_lexer/formatter.cr","line_number":13,"url":"https://github.com/horrendo/pg_sql_lexer/blob/1e20f45772969244d736615cdb3823761b75388a/src/pg_sql_lexer/formatter.cr#L13"}],"repository_name":"pg_sql_lexer","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"pg_sql_lexer/PgSqlLexer","kind":"module","full_name":"PgSqlLexer","name":"PgSqlLexer"},"doc":"\nThis class converts an array of `Token` objects produced by a `Lexer` into a formatted string.\nCurrently the only method is to produce a 'minified' format, but at some point this may be\nexpanded to other formats. Typical usage:\n```\nraw_sql = {slurp from a file maybe}\nminified = PgSqlLexer::Formatter.new(PgSqlLexer::Lexer.new(raw_sql).tokens).format_minified\n:\n```","summary":"<p>This class converts an array of <code><a href=\"../PgSqlLexer/Token.html\">Token</a></code> objects produced by a <code><a href=\"../PgSqlLexer/Lexer.html\">Lexer</a></code> into a formatted string.</p>","class_methods":[],"constructors":[{"id":"new(tokens:Array(Token))-class-method","html_id":"new(tokens:Array(Token))-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[{"name":"tokens","doc":null,"default_value":"","external_name":"tokens","restriction":"Array(Token)"}],"args_string":"(tokens : Array(Token))","source_link":"https://github.com/horrendo/pg_sql_lexer/blob/1e20f45772969244d736615cdb3823761b75388a/src/pg_sql_lexer/formatter.cr#L14","def":{"name":"new","args":[{"name":"tokens","doc":null,"default_value":"","external_name":"tokens","restriction":"Array(Token)"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(tokens)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"format_minified(include_comments=false):String-instance-method","html_id":"format_minified(include_comments=false):String-instance-method","name":"format_minified","doc":"\nThis method takes a collection of tokens and outputs a 'minified' version of the SQL.\n\nThe 'reconstituted' SQL is formatted on a single line (i.e. no newlines) and with no\nmore than one space between tokens. Sometimes there is no space between tokens (e.g.\nif the previous token is a `(`).\n\nFor example (from test suite):\n```\nit \"correctly minifies a statement excluding multi-line comments\" do\n  PgSqlLexer::Formatter.new(\n    PgSqlLexer::Lexer\n      .new(\"SELECT 1\\n/*\\n Some comment\\n*/\\nFROM\\t\\tsome_table\\n;\")\n      .tokens)\n    .format_minified.should eq(\"select 1 from some_table;\")\nend\n```\n","summary":"<p>This method takes a collection of tokens and outputs a 'minified' version of the SQL.</p>","abstract":false,"args":[{"name":"include_comments","doc":null,"default_value":"false","external_name":"include_comments","restriction":""}],"args_string":"(include_comments = <span class=\"n\">false</span>) : String","source_link":"https://github.com/horrendo/pg_sql_lexer/blob/1e20f45772969244d736615cdb3823761b75388a/src/pg_sql_lexer/formatter.cr#L35","def":{"name":"format_minified","args":[{"name":"include_comments","doc":null,"default_value":"false","external_name":"include_comments","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"String","visibility":"Public","body":"String.build do |s|\n  prev_type = :unknown\n  @tokens.each_with_index do |t, i|\n    no_space = (((((prev_type == (:\"(\")) || (prev_type == (:\"[\"))) || (prev_type == (:\"::\"))) || (prev_type == (:\":\"))) || (prev_type == (:\".\"))) || (prev_type == (:unknown))\n    if t.type == (:comment)\n      if include_comments\n      else\n        next\n      end\n      if i == 0\n      else\n        s << ' '\n      end\n      s << \"/* \"\n      s << t.value\n      s << \" */\"\n    else\n      if t.type == (:\")\")\n        s << ')'\n      else\n        if t.type == (:\"]\")\n          s << ']'\n        else\n          if t.type == (:\";\")\n            s << ';'\n          else\n            if t.type == (:\",\")\n              s << ','\n            else\n              if t.type == (:\"::\")\n                s << \"::\"\n              else\n                if t.type == (:\":\")\n                  s << ':'\n                else\n                  if t.type == (:\".\")\n                    s << '.'\n                  else\n                    if t.type == (:\"(\")\n                      if no_space || (prev_type == (:identifier))\n                      else\n                        s << ' '\n                      end\n                      s << '('\n                    else\n                      if t.type == (:\"[\")\n                        if no_space\n                        else\n                          s << ' '\n                        end\n                        s << '['\n                      else\n                        if (t.type == (:keyword)) || (t.type == (:identifier))\n                          if no_space\n                          else\n                            s << ' '\n                          end\n                          s << t.value.try(&.downcase)\n                        else\n                          if no_space\n                          else\n                            s << ' '\n                          end\n                          s << t.value\n                        end\n                      end\n                    end\n                  end\n                end\n              end\n            end\n          end\n        end\n      end\n    end\n    prev_type = t.type\n  end\nend"}}],"macros":[],"types":[]},{"html_id":"pg_sql_lexer/PgSqlLexer/InvalidBinaryBitString","path":"PgSqlLexer/InvalidBinaryBitString.html","kind":"class","full_name":"PgSqlLexer::InvalidBinaryBitString","name":"InvalidBinaryBitString","abstract":false,"superclass":{"html_id":"pg_sql_lexer/Exception","kind":"class","full_name":"Exception","name":"Exception"},"ancestors":[{"html_id":"pg_sql_lexer/Exception","kind":"class","full_name":"Exception","name":"Exception"},{"html_id":"pg_sql_lexer/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"pg_sql_lexer/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/pg_sql_lexer/exceptions.cr","line_number":55,"url":"https://github.com/horrendo/pg_sql_lexer/blob/1e20f45772969244d736615cdb3823761b75388a/src/pg_sql_lexer/exceptions.cr#L55"}],"repository_name":"pg_sql_lexer","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"pg_sql_lexer/PgSqlLexer","kind":"module","full_name":"PgSqlLexer","name":"PgSqlLexer"},"doc":"An exception that is raised if non-binary characters are encountered\nwhile parsing a binary bit-string literal","summary":"<p>An exception that is raised if non-binary characters are encountered while parsing a binary bit-string literal</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]},{"html_id":"pg_sql_lexer/PgSqlLexer/InvalidHexBitString","path":"PgSqlLexer/InvalidHexBitString.html","kind":"class","full_name":"PgSqlLexer::InvalidHexBitString","name":"InvalidHexBitString","abstract":false,"superclass":{"html_id":"pg_sql_lexer/Exception","kind":"class","full_name":"Exception","name":"Exception"},"ancestors":[{"html_id":"pg_sql_lexer/Exception","kind":"class","full_name":"Exception","name":"Exception"},{"html_id":"pg_sql_lexer/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"pg_sql_lexer/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/pg_sql_lexer/exceptions.cr","line_number":64,"url":"https://github.com/horrendo/pg_sql_lexer/blob/1e20f45772969244d736615cdb3823761b75388a/src/pg_sql_lexer/exceptions.cr#L64"}],"repository_name":"pg_sql_lexer","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"pg_sql_lexer/PgSqlLexer","kind":"module","full_name":"PgSqlLexer","name":"PgSqlLexer"},"doc":"An exception that is raised if non-hexidecimal characters are encountered\nwhile parsing a hexidecimal  bit-string literal","summary":"<p>An exception that is raised if non-hexidecimal characters are encountered while parsing a hexidecimal  bit-string literal</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]},{"html_id":"pg_sql_lexer/PgSqlLexer/InvalidIdentifier","path":"PgSqlLexer/InvalidIdentifier.html","kind":"class","full_name":"PgSqlLexer::InvalidIdentifier","name":"InvalidIdentifier","abstract":false,"superclass":{"html_id":"pg_sql_lexer/Exception","kind":"class","full_name":"Exception","name":"Exception"},"ancestors":[{"html_id":"pg_sql_lexer/Exception","kind":"class","full_name":"Exception","name":"Exception"},{"html_id":"pg_sql_lexer/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"pg_sql_lexer/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/pg_sql_lexer/exceptions.cr","line_number":46,"url":"https://github.com/horrendo/pg_sql_lexer/blob/1e20f45772969244d736615cdb3823761b75388a/src/pg_sql_lexer/exceptions.cr#L46"}],"repository_name":"pg_sql_lexer","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"pg_sql_lexer/PgSqlLexer","kind":"module","full_name":"PgSqlLexer","name":"PgSqlLexer"},"doc":"An exception that is raised if non-numeric characters are encountered\nwhile parsing a numeric literal","summary":"<p>An exception that is raised if non-numeric characters are encountered while parsing a numeric literal</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]},{"html_id":"pg_sql_lexer/PgSqlLexer/InvalidNumericLiteral","path":"PgSqlLexer/InvalidNumericLiteral.html","kind":"class","full_name":"PgSqlLexer::InvalidNumericLiteral","name":"InvalidNumericLiteral","abstract":false,"superclass":{"html_id":"pg_sql_lexer/Exception","kind":"class","full_name":"Exception","name":"Exception"},"ancestors":[{"html_id":"pg_sql_lexer/Exception","kind":"class","full_name":"Exception","name":"Exception"},{"html_id":"pg_sql_lexer/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"pg_sql_lexer/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/pg_sql_lexer/exceptions.cr","line_number":37,"url":"https://github.com/horrendo/pg_sql_lexer/blob/1e20f45772969244d736615cdb3823761b75388a/src/pg_sql_lexer/exceptions.cr#L37"}],"repository_name":"pg_sql_lexer","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"pg_sql_lexer/PgSqlLexer","kind":"module","full_name":"PgSqlLexer","name":"PgSqlLexer"},"doc":"An exception that is raised if the closing */ is not found for\na comment","summary":"<p>An exception that is raised if the closing */ is not found for a comment</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]},{"html_id":"pg_sql_lexer/PgSqlLexer/InvalidOperator","path":"PgSqlLexer/InvalidOperator.html","kind":"class","full_name":"PgSqlLexer::InvalidOperator","name":"InvalidOperator","abstract":false,"superclass":{"html_id":"pg_sql_lexer/Exception","kind":"class","full_name":"Exception","name":"Exception"},"ancestors":[{"html_id":"pg_sql_lexer/Exception","kind":"class","full_name":"Exception","name":"Exception"},{"html_id":"pg_sql_lexer/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"pg_sql_lexer/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/pg_sql_lexer/exceptions.cr","line_number":74,"url":"https://github.com/horrendo/pg_sql_lexer/blob/1e20f45772969244d736615cdb3823761b75388a/src/pg_sql_lexer/exceptions.cr#L74"}],"repository_name":"pg_sql_lexer","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"pg_sql_lexer/PgSqlLexer","kind":"module","full_name":"PgSqlLexer","name":"PgSqlLexer"},"doc":"An exception that is raised if an invalid character is encountered\nwhile parsing an operator, or the resulting operator violates\npostgres naming rules","summary":"<p>An exception that is raised if an invalid character is encountered while parsing an operator, or the resulting operator violates postgres naming rules</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]},{"html_id":"pg_sql_lexer/PgSqlLexer/Keyword","path":"PgSqlLexer/Keyword.html","kind":"class","full_name":"PgSqlLexer::Keyword","name":"Keyword","abstract":false,"superclass":{"html_id":"pg_sql_lexer/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"pg_sql_lexer/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"pg_sql_lexer/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/pg_sql_lexer/keyword.cr","line_number":32,"url":"https://github.com/horrendo/pg_sql_lexer/blob/1e20f45772969244d736615cdb3823761b75388a/src/pg_sql_lexer/keyword.cr#L32"}],"repository_name":"pg_sql_lexer","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"pg_sql_lexer/PgSqlLexer","kind":"module","full_name":"PgSqlLexer","name":"PgSqlLexer"},"doc":"\nThis class defines two collections of keywords. The [Postgres Docs](https://www.postgresql.org/docs/current/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS) define\na category of lexical element - 'Identifiers and Keywords'. Syntactically they are very similar so it is\nnot always easy to distinguish between them. In writing this library I didn't actually need to\ndistinguish but I recognise someone elses needs may differ. Postgres makes the keywords available\nfrom the builtin function `pg_get_keywords`. For example:\n\n```sql\nb2bc_dev=# select * from pg_get_keywords();\n       word        | catcode |                   catdesc\n-------------------+---------+----------------------------------------------\n abort             | U       | unreserved\n absolute          | U       | unreserved\n access            | U       | unreserved\n action            | U       | unreserved\n add               | U       | unreserved\n admin             | U       | unreserved\n after             | U       | unreserved\n aggregate         | U       | unreserved\n all               | R       | reserved\n :\n```\nThe `reserved` set of keywords is defined by the query `select word from pg_get_keywords() where catcode != 'U'`.\n\nThe `non-reserved` set of keywords is defined by the query `select word from pg_get_keywords() where catcode = 'U'`.\n\nThis class is not typically accessed directly, but is used by the `Lexer` class. The constructor\nfor the `Lexer` class allows you to control which set or sets of keywords are used during the\nparsing process. This will control whether a `Token` has a `type` of `:keyword` or `:identifier`.\n","summary":"<p>This class defines two collections of keywords.</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]},{"html_id":"pg_sql_lexer/PgSqlLexer/Lexer","path":"PgSqlLexer/Lexer.html","kind":"class","full_name":"PgSqlLexer::Lexer","name":"Lexer","abstract":false,"superclass":{"html_id":"pg_sql_lexer/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"pg_sql_lexer/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"pg_sql_lexer/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/pg_sql_lexer/lexer.cr","line_number":32,"url":"https://github.com/horrendo/pg_sql_lexer/blob/1e20f45772969244d736615cdb3823761b75388a/src/pg_sql_lexer/lexer.cr#L32"}],"repository_name":"pg_sql_lexer","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"pg_sql_lexer/PgSqlLexer","kind":"module","full_name":"PgSqlLexer","name":"PgSqlLexer"},"doc":"A lexer is a tool that analyzes a stream of text and generates a list of tokens that have been\nidentified in that stream. This simple class is designed to take a string representing some\nSQL that has already been identified as syntactically correct by the postgres DB. For example\nit may be some SQL from a log file (my use case).\n\nTo instantiate an instance of this class you pass a string with the SQL to parse into tokens.\nYou can optionally control the sets of words that the lexer recognises as keywords. Refer to\nthe `Keyword` class, but basically there are two sets of keywords - reserved and non-reserved.\nBy default the lexer will only use the 'reserved' set of keywords but you can change this via\narguments to the constructor.\n\nAs part of instantiation the string will be parsed and if no errors are encounted the `tokens`\nproperty will contain all tokens encountered during this process.\n\nThe parsing rules have been mostly derived from the [Postgres Docs](https://www.postgresql.org/docs/current/sql-syntax.html).\n\nHere is an example of this class being used:\n```\nraw_sql = {slurp from a file maybe}\nminified = PgSqlLexer::Formatter.new(PgSqlLexer::Lexer.new(raw_sql).tokens).format_minified\n:\n```\n","summary":"<p>A lexer is a tool that analyzes a stream of text and generates a list of tokens that have been identified in that stream.</p>","class_methods":[],"constructors":[{"id":"new(buffer:String,use_reserved_keywords=true,use_non_reserved_keywords=false)-class-method","html_id":"new(buffer:String,use_reserved_keywords=true,use_non_reserved_keywords=false)-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[{"name":"buffer","doc":null,"default_value":"","external_name":"buffer","restriction":"String"},{"name":"use_reserved_keywords","doc":null,"default_value":"true","external_name":"use_reserved_keywords","restriction":""},{"name":"use_non_reserved_keywords","doc":null,"default_value":"false","external_name":"use_non_reserved_keywords","restriction":""}],"args_string":"(buffer : String, use_reserved_keywords = <span class=\"n\">true</span>, use_non_reserved_keywords = <span class=\"n\">false</span>)","source_link":"https://github.com/horrendo/pg_sql_lexer/blob/1e20f45772969244d736615cdb3823761b75388a/src/pg_sql_lexer/lexer.cr#L38","def":{"name":"new","args":[{"name":"buffer","doc":null,"default_value":"","external_name":"buffer","restriction":"String"},{"name":"use_reserved_keywords","doc":null,"default_value":"true","external_name":"use_reserved_keywords","restriction":""},{"name":"use_non_reserved_keywords","doc":null,"default_value":"false","external_name":"use_non_reserved_keywords","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(buffer, use_reserved_keywords, use_non_reserved_keywords)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[],"macros":[],"types":[]},{"html_id":"pg_sql_lexer/PgSqlLexer/MissingEndComment","path":"PgSqlLexer/MissingEndComment.html","kind":"class","full_name":"PgSqlLexer::MissingEndComment","name":"MissingEndComment","abstract":false,"superclass":{"html_id":"pg_sql_lexer/Exception","kind":"class","full_name":"Exception","name":"Exception"},"ancestors":[{"html_id":"pg_sql_lexer/Exception","kind":"class","full_name":"Exception","name":"Exception"},{"html_id":"pg_sql_lexer/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"pg_sql_lexer/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/pg_sql_lexer/exceptions.cr","line_number":4,"url":"https://github.com/horrendo/pg_sql_lexer/blob/1e20f45772969244d736615cdb3823761b75388a/src/pg_sql_lexer/exceptions.cr#L4"}],"repository_name":"pg_sql_lexer","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"pg_sql_lexer/PgSqlLexer","kind":"module","full_name":"PgSqlLexer","name":"PgSqlLexer"},"doc":"An exception that is raised if the closing `*/` is not found for\na comment","summary":"<p>An exception that is raised if the closing <code>*/</code> is not found for a comment</p>","class_methods":[],"constructors":[{"id":"new-class-method","html_id":"new-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","source_link":"https://github.com/horrendo/pg_sql_lexer/blob/1e20f45772969244d736615cdb3823761b75388a/src/pg_sql_lexer/exceptions.cr#L5","def":{"name":"new","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[],"macros":[],"types":[]},{"html_id":"pg_sql_lexer/PgSqlLexer/MissingEndQuotedIdentifier","path":"PgSqlLexer/MissingEndQuotedIdentifier.html","kind":"class","full_name":"PgSqlLexer::MissingEndQuotedIdentifier","name":"MissingEndQuotedIdentifier","abstract":false,"superclass":{"html_id":"pg_sql_lexer/Exception","kind":"class","full_name":"Exception","name":"Exception"},"ancestors":[{"html_id":"pg_sql_lexer/Exception","kind":"class","full_name":"Exception","name":"Exception"},{"html_id":"pg_sql_lexer/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"pg_sql_lexer/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/pg_sql_lexer/exceptions.cr","line_number":12,"url":"https://github.com/horrendo/pg_sql_lexer/blob/1e20f45772969244d736615cdb3823761b75388a/src/pg_sql_lexer/exceptions.cr#L12"}],"repository_name":"pg_sql_lexer","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"pg_sql_lexer/PgSqlLexer","kind":"module","full_name":"PgSqlLexer","name":"PgSqlLexer"},"doc":"An exception that is raised if the closing `\"` is not found for\na double-quoted identifier","summary":"<p>An exception that is raised if the closing <code>\"</code> is not found for a double-quoted identifier</p>","class_methods":[],"constructors":[{"id":"new-class-method","html_id":"new-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","source_link":"https://github.com/horrendo/pg_sql_lexer/blob/1e20f45772969244d736615cdb3823761b75388a/src/pg_sql_lexer/exceptions.cr#L13","def":{"name":"new","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[],"macros":[],"types":[]},{"html_id":"pg_sql_lexer/PgSqlLexer/MissingEndQuotedLiteral","path":"PgSqlLexer/MissingEndQuotedLiteral.html","kind":"class","full_name":"PgSqlLexer::MissingEndQuotedLiteral","name":"MissingEndQuotedLiteral","abstract":false,"superclass":{"html_id":"pg_sql_lexer/Exception","kind":"class","full_name":"Exception","name":"Exception"},"ancestors":[{"html_id":"pg_sql_lexer/Exception","kind":"class","full_name":"Exception","name":"Exception"},{"html_id":"pg_sql_lexer/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"pg_sql_lexer/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/pg_sql_lexer/exceptions.cr","line_number":20,"url":"https://github.com/horrendo/pg_sql_lexer/blob/1e20f45772969244d736615cdb3823761b75388a/src/pg_sql_lexer/exceptions.cr#L20"}],"repository_name":"pg_sql_lexer","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"pg_sql_lexer/PgSqlLexer","kind":"module","full_name":"PgSqlLexer","name":"PgSqlLexer"},"doc":"An exception that is raised if the closing `'` is not found for\na string literal","summary":"<p>An exception that is raised if the closing <code>'</code> is not found for a string literal</p>","class_methods":[],"constructors":[{"id":"new-class-method","html_id":"new-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","source_link":"https://github.com/horrendo/pg_sql_lexer/blob/1e20f45772969244d736615cdb3823761b75388a/src/pg_sql_lexer/exceptions.cr#L21","def":{"name":"new","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[],"macros":[],"types":[]},{"html_id":"pg_sql_lexer/PgSqlLexer/NoZeroLengthQuotedIdentifier","path":"PgSqlLexer/NoZeroLengthQuotedIdentifier.html","kind":"class","full_name":"PgSqlLexer::NoZeroLengthQuotedIdentifier","name":"NoZeroLengthQuotedIdentifier","abstract":false,"superclass":{"html_id":"pg_sql_lexer/Exception","kind":"class","full_name":"Exception","name":"Exception"},"ancestors":[{"html_id":"pg_sql_lexer/Exception","kind":"class","full_name":"Exception","name":"Exception"},{"html_id":"pg_sql_lexer/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"pg_sql_lexer/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/pg_sql_lexer/exceptions.cr","line_number":28,"url":"https://github.com/horrendo/pg_sql_lexer/blob/1e20f45772969244d736615cdb3823761b75388a/src/pg_sql_lexer/exceptions.cr#L28"}],"repository_name":"pg_sql_lexer","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"pg_sql_lexer/PgSqlLexer","kind":"module","full_name":"PgSqlLexer","name":"PgSqlLexer"},"doc":"An exception that is raised if two consecutive `\"` characters\nare encountered","summary":"<p>An exception that is raised if two consecutive <code>\"</code> characters are encountered</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]},{"html_id":"pg_sql_lexer/PgSqlLexer/Token","path":"PgSqlLexer/Token.html","kind":"class","full_name":"PgSqlLexer::Token","name":"Token","abstract":false,"superclass":{"html_id":"pg_sql_lexer/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"pg_sql_lexer/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"pg_sql_lexer/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/pg_sql_lexer/token.cr","line_number":33,"url":"https://github.com/horrendo/pg_sql_lexer/blob/1e20f45772969244d736615cdb3823761b75388a/src/pg_sql_lexer/token.cr#L33"}],"repository_name":"pg_sql_lexer","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"pg_sql_lexer/PgSqlLexer","kind":"module","full_name":"PgSqlLexer","name":"PgSqlLexer"},"doc":"\nDefines a token encountered while parsing an SQL string. A token has the following properties:\n* `type` - A `Symbol` describing the type of the token\n* `value` - A `String` containing the value of the token from the source string. Not every token type has a value.\n\nThe following token types are defined:\n\n`value` property populated\n* `:keyword`\n* `:identifier`\n* `:operator`\n* `:string_constant`\n* `:numeric_constant`\n* `:quoted_identifier`\n* `:positional_parameter`\n* `:binary_bit_string`\n* `:hex_bit_string`\n* `:comment` (Minified whitespace and multi-line comments are collapsed)\n\n`value` property `nil`\n* `:\"(\"`\n* `:\")\"`\n* `:\"[\"`\n* `:\"]\"`\n* `:\",\"`\n* `:\";\"`\n* `:\"..\"`\n* `:\".\"`\n* `:\"::\"`\n* `:\":\"`\n","summary":"<p>Defines a token encountered while parsing an SQL string.</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]}]}]}}